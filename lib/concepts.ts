import { Concept } from './types';

export const CONCEPTS: Concept[] = [
  {
    id: 'referential-transparency',
    num: '01', part: 'FOUNDATIONS',
    title: 'Referential Transparency',
    tagline: '"Can I trust this function completely?"',
    cardDesc: 'The one rule that makes code easy to test, debug, and reason about.',
    tags: ['core', 'pure functions', 'testing'],
    demoId: 'substitution',
  },
  {
    id: 'pure-core',
    num: '02', part: 'FOUNDATIONS',
    title: 'Pure Core / Thin Shell',
    tagline: '"Keep business logic separate from side effects."',
    cardDesc: 'The architecture that makes complex software testable with zero mocks.',
    tags: ['architecture', 'testing', 'design'],
    demoId: undefined,
  },
  {
    id: 'immutable-data',
    num: '11', part: 'FOUNDATIONS',
    title: 'Immutable Data & Structural Sharing',
    tagline: '"Never modify — create a new version with the change."',
    cardDesc: 'Why immutable data structures are fast, safe, and enable time-travel debugging.',
    tags: ['immutability', 'data structures', 'sharing'],
    demoId: undefined,
  },
  {
    id: 'errors-as-values',
    num: '03', part: 'FOUNDATIONS',
    title: 'Errors as Values',
    tagline: '"Return failures — don\'t throw them."',
    cardDesc: 'How Option/Result/Either make error handling composable and visible.',
    tags: ['option', 'result', 'error handling'],
    demoId: 'railway',
  },
  {
    id: 'laziness',
    num: '04', part: 'FOUNDATIONS',
    title: 'Laziness & Pipeline Fusion',
    tagline: '"Process data only when you need it."',
    cardDesc: 'How lazy evaluation fuses pipelines and enables infinite sequences.',
    tags: ['streams', 'generators', 'performance'],
    demoId: 'pipeline',
  },
  {
    id: 'functional-state',
    num: '05', part: 'FOUNDATIONS',
    title: 'State as a Return Value',
    tagline: '"Never mutate — return the new state."',
    cardDesc: 'The pattern behind Redux, React\'s useReducer, and testable state machines.',
    tags: ['state', 'redux', 'immutability'],
    demoId: 'state',
  },
  {
    id: 'api-first-design',
    num: '12', part: 'DESIGN',
    title: 'API-First Design',
    tagline: '"Dream the call site — then work backward."',
    cardDesc: 'The FP method for designing libraries: start from ideal usage, derive types and laws.',
    tags: ['design', 'api', 'library design'],
    demoId: undefined,
  },
  {
    id: 'laws-as-design',
    num: '13', part: 'DESIGN',
    title: 'Laws as Design Tools',
    tagline: '"Write equations, not just examples — laws find bugs nothing else catches."',
    cardDesc: 'Every abstraction has laws. Testing them as properties catches bugs that code review misses.',
    tags: ['laws', 'property testing', 'correctness'],
    demoId: undefined,
  },
  {
    id: 'property-testing',
    num: '06', part: 'DESIGN',
    title: 'Property-Based Testing',
    tagline: '"Write rules, not examples — let the machine find bugs."',
    cardDesc: 'Specify invariants; the framework generates hundreds of random test cases.',
    tags: ['testing', 'hypothesis', 'quickcheck'],
    demoId: 'pbt',
  },
  {
    id: 'monoids',
    num: '07', part: 'ABSTRACTIONS',
    title: 'Monoids & Associativity',
    tagline: '"Split it, compute in parallel, combine — same answer."',
    cardDesc: 'Why associativity unlocks free parallelism in MapReduce, Spark, and more.',
    tags: ['monoid', 'parallelism', 'aggregation'],
    demoId: 'monoid',
  },
  {
    id: 'functor',
    num: '14', part: 'ABSTRACTIONS',
    title: 'Functor — Map Everything',
    tagline: '"Transform the value inside without changing the container."',
    cardDesc: 'The simplest context-aware abstraction. Arrays, Promises, Options are all functors.',
    tags: ['functor', 'map', 'context'],
    demoId: undefined,
  },
  {
    id: 'monad-pattern',
    num: '08', part: 'ABSTRACTIONS',
    title: 'The Monad Pattern',
    tagline: '"Chain operations where each step might fail or be async."',
    cardDesc: 'The pattern behind Promises, async/await, optional chaining, and Result types.',
    tags: ['monad', 'flatmap', 'chaining'],
    demoId: 'chain',
  },
  {
    id: 'applicative',
    num: '09', part: 'ABSTRACTIONS',
    title: 'Applicative vs Monad',
    tagline: '"Independent things should run independently."',
    cardDesc: 'When to use Applicative (parallel/collect-all) vs Monad (sequential/fail-fast).',
    tags: ['applicative', 'validation', 'parallel'],
    demoId: 'applicative',
  },
  {
    id: 'description-execution',
    num: '10', part: 'EFFECTS & IO',
    title: 'Description vs Execution',
    tagline: '"Write a recipe, then cook it — not while writing."',
    cardDesc: 'The FP strategy for IO, streaming, and all side effects. SQL and React already do this.',
    tags: ['io', 'effects', 'streaming'],
    demoId: undefined,
  },
  {
    id: 'trampolining',
    num: '15', part: 'EFFECTS & IO',
    title: 'Trampolining & Stack Safety',
    tagline: '"Turn deep recursion into a loop — zero stack overflow risk."',
    cardDesc: 'How to make any recursive algorithm stack-safe by returning thunks instead of calling.',
    tags: ['recursion', 'stack safety', 'performance'],
    demoId: undefined,
  },
  {
    id: 'stream-processing',
    num: '16', part: 'EFFECTS & IO',
    title: 'Stream Processing',
    tagline: '"Process data as it flows — never load it all at once."',
    cardDesc: 'Composable state machines that transform data streams with constant memory and resource safety.',
    tags: ['streaming', 'io', 'composability'],
    demoId: undefined,
  },
];

export function getConcept(id: string): Concept | undefined {
  return CONCEPTS.find(c => c.id === id);
}

export function getAdjacentConcepts(id: string) {
  const idx = CONCEPTS.findIndex(c => c.id === id);
  return {
    prev: idx > 0 ? CONCEPTS[idx - 1] : null,
    next: idx < CONCEPTS.length - 1 ? CONCEPTS[idx + 1] : null,
  };
}
